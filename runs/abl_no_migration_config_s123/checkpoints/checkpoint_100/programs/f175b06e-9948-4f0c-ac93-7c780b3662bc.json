{"id": "f175b06e-9948-4f0c-ac93-7c780b3662bc", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n", "language": "python", "parent_id": "7dc4f1f4-dd79-4c9e-ae72-0ef6b7f69b46", "generation": 2, "timestamp": 1755446071.648381, "iteration_found": 100, "metrics": {"runs_successfully": 1.0, "value_score": 0.9899325994817513, "distance_score": 0.7118820931298168, "overall_score": 0.961107338562478, "standard_deviation_score": 0.5495077519917028, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.8055366928123895, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 8 lines with 18 lines", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.9499224344912157, "distance_score": 0.6257886328564164, "overall_score": 0.951829901138098, "standard_deviation_score": 0.5382531605940895, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.7591495056904892, "success_rate": 1.0}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"diff_user": {"system": "You are an expert coder helping to improve programs through evolution.", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 1.0000\n- value_score: 0.9499\n- distance_score: 0.6258\n- overall_score: 0.9518\n- standard_deviation_score: 0.5383\n- speed_score: 1.0000\n- reliability_score: 1.0000\n- combined_score: 0.7591\n- success_rate: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: value_score, distance_score, overall_score, standard_deviation_score, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9996, distance_score: 0.9916, overall_score: 0.9991, standard_deviation_score: 0.9927, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9954, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9996, distance_score: 0.9914, overall_score: 0.9992, standard_deviation_score: 0.9949, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9958, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9996, distance_score: 0.9921, overall_score: 0.9992, standard_deviation_score: 0.9941, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9959, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9979)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9996), Performs well on distance_score (0.9921), Performs well on overall_score (0.9992), Performs well on standard_deviation_score (0.9941), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9959), Performs well on success_rate (1.0000)\n\n\n### Program 2 (Score: 0.9979)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An adaptive search algorithm that balances exploration and exploitation.\n    \n    Starts with broad exploration and gradually focuses on promising areas by\n    decreasing the search width around the best found solution over time.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9996), Performs well on distance_score (0.9914), Performs well on overall_score (0.9992), Performs well on standard_deviation_score (0.9949), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9958), Performs well on success_rate (1.0000)\n\n\n### Program 3 (Score: 0.9976)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An adaptive search algorithm that balances exploration and exploitation.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9996), Performs well on distance_score (0.9916), Performs well on overall_score (0.9991), Performs well on standard_deviation_score (0.9927), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9954), Performs well on success_rate (1.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9975)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An adaptive search algorithm that balances exploration and exploitation.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Generate initial random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n\n### Program D2 (Score: 0.9975)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm for function minimization.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Generate initial random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        search_width = (bounds[1] - bounds[0]) * (1 - i / iterations)\n        \n        # Search around best point with decreasing radius\n        dx, dy = np.random.uniform(-search_width/2, search_width/2, 2)\n        x, y = np.clip([best_x + dx, best_y + dy], bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        # Update best solution if improved\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9979, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 4 lines with 3 lines\nChange 2: Replace 9 lines with 18 lines, Excellent runs_successfully (1.000), Excellent value_score (1.000)\n\n\n### Inspiration 2 (Score: 0.9430, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm for function minimization.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        x, y = np.random.uniform(bounds[0], bounds[1], 2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value, best_x, best_y = value, x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 10 lines with 10 lines\nChange 2: Replace 7 lines with 5 lines, Excellent runs_successfully (1.000), Excellent value_score (0.947)\n\n\n### Inspiration 3 (Score: 0.9587, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Generate random candidate point\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 4 lines with 3 lines\nChange 2: Replace 9 lines with 9 lines, Excellent runs_successfully (1.000), Excellent value_score (0.970)\n\n\n### Inspiration 4 (Score: 0.9579, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    # Generate initial point more concisely\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Simple random search\n        # Generate candidate point more concisely\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 2 lines with 2 lines\nChange 2: Replace 2 lines with 2 lines, Excellent runs_successfully (1.000), Excellent value_score (0.966)\n\n\n### Inspiration 5 (Score: 0.9912, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5), local_search_prob=0.3, local_search_range=0.5):\n    \"\"\"\n    An improved random search algorithm with local search to avoid local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n        local_search_prob: Probability of searching near best solution (0-1)\n        local_search_range: Range for local search exploration\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < local_search_prob:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, local_search_range), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, local_search_range), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 11 lines with 13 lines\nChange 2: Replace 2 lines with 8 lines, Excellent runs_successfully (1.000), Excellent value_score (0.998)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Generate random coordinates\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\n\n# Task\nSuggest improvements to the program that will lead to better performance on the specified metrics.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n", "responses": ["# Analysis of Current Performance Issues\n\nThe current program is using a simple random search algorithm that generates completely random points throughout the search space. While this is simple to implement, it's inefficient at finding optimal solutions compared to the adaptive search approaches used in the top-performing programs. This explains the significant drop in value_score, distance_score, and other metrics compared to previous versions.\n\n# Proposed Improvements\n\nTo restore performance while maintaining readability, I recommend reintroducing the adaptive search strategy from the top-performing programs:\n\n```diff\n<<<<<<< SEARCH\n    for _ in range(iterations):\n        # Generate random coordinates\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n=======\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n>>>>>>> REPLACE\n```\n\n# Explanation of Changes\n\nThe key improvements in this change are:\n\n1. **Adaptive Exploration Strategy**: The algorithm starts with broad exploration of the entire search space and gradually focuses on promising areas by decreasing the search width over time. This is controlled by the `exploration_factor` that goes from 1 to 0 over iterations.\n\n2. **Local Search Around Best Solution**: Instead of generating completely random points, we now search around the best solution found so far, with a radius that decreases over time. This balances exploration (finding new areas) and exploitation (refining known good areas).\n\n3. **Boundary Enforcement**: The `np.clip()` function ensures we stay within the search bounds even when exploring around the best solution.\n\nThese changes should significantly improve:\n- `value_score`: By finding better minima\n- `distance_score`: By getting closer to the true minimum\n- `overall_score` and `combined_score`: Through the above improvements\n- `standard_deviation_score`: By producing more consistent results\n\nThe code remains readable and maintains the same time complexity while being much more effective at finding optimal solutions."]}}}