{"id": "ab6d620d-faa4-47f3-865e-e4c58ef71aa1", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A balanced search algorithm with local exploration and global search.\n    \n    Combines local search around promising solutions with global exploration\n    to efficiently find function minima within specified bounds.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n", "language": "python", "parent_id": "2278fac9-2a63-46d2-ad50-1b2299ee509f", "generation": 3, "timestamp": 1755445887.1360836, "iteration_found": 72, "metrics": {"runs_successfully": 1.0, "value_score": 0.9898427776837186, "distance_score": 0.7106361762761436, "overall_score": 0.9610496425905654, "standard_deviation_score": 0.5504028953343738, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.8052482129528266, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 17 lines with 16 lines", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.997523322128746, "distance_score": 0.9600437134267472, "overall_score": 0.9959976309555562, "standard_deviation_score": 0.9741984616667879, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.9799881547777803, "success_rate": 1.0}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"diff_user": {"system": "You are an expert coder helping to improve programs through evolution.", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 1.0000\n- value_score: 0.9975\n- distance_score: 0.9600\n- overall_score: 0.9960\n- standard_deviation_score: 0.9742\n- speed_score: 1.0000\n- reliability_score: 1.0000\n- combined_score: 0.9800\n- success_rate: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: value_score, distance_score, overall_score, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9980, distance_score: 0.9648, overall_score: 0.9963, standard_deviation_score: 0.9724, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9814, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9983, distance_score: 0.9692, overall_score: 0.9968, standard_deviation_score: 0.9764, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9839, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9995, distance_score: 0.9885, overall_score: 0.9988, standard_deviation_score: 0.9915, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9941, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9969)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simplified adaptive search algorithm that finds function minima.\n    \n    Starts with broad exploration and gradually focuses on promising areas.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        # Update best solution if improved\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9995), Performs well on distance_score (0.9885), Performs well on overall_score (0.9988), Performs well on standard_deviation_score (0.9915), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9941), Performs well on success_rate (1.0000)\n\n\n### Program 2 (Score: 0.9916)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simplified random search algorithm with local refinement to find minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Configuration constants\n    LOCAL_SEARCH_PROB = 0.2  # 20% chance for local search\n    LOCAL_SEARCH_RANGE = 0.5  # Standard deviation for local search\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < LOCAL_SEARCH_PROB:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9983), Performs well on distance_score (0.9692), Performs well on overall_score (0.9968), Performs well on standard_deviation_score (0.9764), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9839), Performs well on success_rate (1.0000)\n\n\n### Program 3 (Score: 0.9903)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5), local_search_prob=0.3, local_search_range=0.5):\n    \"\"\"\n    An improved random search algorithm with local search to avoid local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n        local_search_prob: Probability of searching near best solution (0-1)\n        local_search_range: Range for local search exploration\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < local_search_prob:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, local_search_range), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, local_search_range), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9980), Performs well on distance_score (0.9648), Performs well on overall_score (0.9963), Performs well on standard_deviation_score (0.9724), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9814), Performs well on success_rate (1.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9721)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    Random search algorithm for function minimization within specified bounds.\n    \n    Explores the search space by evaluating random points and tracking the minimum value found.\n\n    Args:\n        iterations: Number of search iterations\n        bounds: Tuple specifying (min, max) search range\n        \n    Returns:\n        (best_x, best_y, best_value): Coordinates and value of the minimum found\n    \"\"\"\n    # Initialize with random point\n    best_x, best_y = np.random.uniform(*bounds, 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    # Search for minimum\n    for _ in range(iterations):\n        x, y = np.random.uniform(*bounds, 2)\n        value = evaluate_function(x, y)\n\n        # Update best if current is better\n        if value < best_value:\n            best_value, best_x, best_y = value, x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n\n### Program D2 (Score: 0.9898)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A balanced search algorithm with local exploration and global search.\n    \n    Combines local search around promising solutions with global exploration\n    to efficiently find function minima within specified bounds.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Configuration constants\n    LOCAL_SEARCH_PROB = 0.2  # 20% chance for local search\n    LOCAL_SEARCH_RANGE = 0.5  # Standard deviation for local search\n    \n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < LOCAL_SEARCH_PROB:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9969, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simplified adaptive search algorithm that finds function minima.\n    \n    Starts with broad exploration and gradually focuses on promising areas.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n        \n        value = evaluate_function(x, y)\n\n        # Update best solution if improved\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 33 lines with 36 lines, Excellent runs_successfully (1.000), Excellent value_score (1.000)\n\n\n### Inspiration 2 (Score: 0.9916, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simplified random search algorithm with local refinement to find minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Configuration constants\n    LOCAL_SEARCH_PROB = 0.2  # 20% chance for local search\n    LOCAL_SEARCH_RANGE = 0.5  # Standard deviation for local search\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < LOCAL_SEARCH_PROB:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 13 lines with 14 lines\nChange 2: Replace 4 lines with 4 lines, Excellent runs_successfully (1.000), Excellent value_score (0.998)\n\n\n### Inspiration 3 (Score: 0.9655, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom typing import Tuple\n\n\ndef search_algorithm(iterations: int = 1000, bounds: Tuple[float, float] = (-5, 5)) -> Tuple[float, float, float]:\n    \"\"\"\n    Random search optimization algorithm for function minimization.\n    \n    Generates random points within specified bounds and keeps track of the minimum value found.\n\n    Args:\n        iterations: Number of iterations to run (default: 1000)\n        bounds: Tuple containing search space minimum and maximum values (default: (-5, 5))\n\n    Returns:\n        Tuple containing (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Simple random search\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Excellent runs_successfully (1.000), Excellent value_score (0.978), Excellent overall_score (0.987)\n\n\n### Inspiration 4 (Score: 0.9903, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5), local_search_prob=0.3, local_search_range=0.5):\n    \"\"\"\n    An improved random search algorithm with local search to avoid local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n        local_search_prob: Probability of searching near best solution (0-1)\n        local_search_range: Range for local search exploration\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < local_search_prob:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, local_search_range), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, local_search_range), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 23 lines with 32 lines, Excellent runs_successfully (1.000), Excellent value_score (0.998)\n\n\n### Inspiration 5 (Score: 0.9675, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point using tuple unpacking\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Simple random search using tuple unpacking\n        x, y = np.random.uniform(bounds[0], bounds[1], 2)\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nUnique approach: Modification: Change 1: Replace 3 lines with 2 lines\nChange 2: Replace 3 lines with 2 lines, Excellent runs_successfully (1.000), Excellent value_score (0.978)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A balanced search algorithm with local exploration and global search.\n    \n    Combines local search around promising solutions with global exploration\n    to efficiently find function minima within specified bounds.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Configuration constants\n    LOCAL_SEARCH_PROB = 0.2  # 20% chance for local search\n    LOCAL_SEARCH_RANGE = 0.5  # Standard deviation for local search\n    \n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < LOCAL_SEARCH_PROB:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n            \n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\n\n# Task\nSuggest improvements to the program that will lead to better performance on the specified metrics.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n", "responses": ["To address the regressions in value_score, distance_score, overall_score, and combined_score while maintaining readability, I recommend implementing an adaptive search strategy inspired by Program 1, which had superior performance metrics.\n\n```python\n<<<<<<< SEARCH\n    # Configuration constants\n    LOCAL_SEARCH_PROB = 0.2  # 20% chance for local search\n    LOCAL_SEARCH_RANGE = 0.5  # Standard deviation for local search\n    \n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # With probability, search locally around best solution\n        if np.random.random() < LOCAL_SEARCH_PROB:\n            # Generate candidate near best solution with normal distribution\n            x = np.clip(best_x + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n            y = np.clip(best_y + np.random.normal(0, LOCAL_SEARCH_RANGE), bounds[0], bounds[1])\n        else:\n            # Generate random coordinates globally\n            x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n=======\n    # Initialize with random coordinates\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], 2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for i in range(iterations):\n        # Adaptive search: start broad, then focus on promising areas\n        exploration_factor = 1 - (i / iterations)\n        search_width = (bounds[1] - bounds[0]) * exploration_factor\n        \n        # Search around best point with decreasing radius\n        x = best_x + np.random.uniform(-search_width/2, search_width/2)\n        y = best_y + np.random.uniform(-search_width/2, search_width/2)\n        \n        # Keep within bounds\n        x = np.clip(x, bounds[0], bounds[1])\n        y = np.clip(y, bounds[0], bounds[1])\n>>>>>>> REPLACE\n```\n\nThis change:\n1. Replaces the fixed-probability local/global search with an adaptive approach that gradually focuses exploration\n2. Starts with broad exploration of the entire search space\n3. Progressively narrows the search area around the best found solution\n4. Maintains simplicity while improving optimization performance\n5. Removes magic constants by calculating search width from bounds\n\nThe adaptive approach should recover the lost performance by:\n- Better balancing exploration (finding new areas) and exploitation (refining known good areas)\n- Gradually focusing on promising regions rather than using fixed probabilities\n- Maintaining coverage of the search space while increasing precision over time\n\nThis aligns with the top-performing Program 1's strategy which demonstrated superior value_score (0.9995 vs current 0.9975) and distance_score (0.9885 vs current 0.9600)."]}}}