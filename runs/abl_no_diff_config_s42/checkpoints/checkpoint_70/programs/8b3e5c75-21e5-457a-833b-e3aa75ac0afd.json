{"id": "8b3e5c75-21e5-457a-833b-e3aa75ac0afd", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates and evaluate\n    best_coords = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(*best_coords)  # * unpacks coordinates into x, y\n\n    for _ in range(iterations):\n        # Generate new candidate solution and evaluate\n        coords = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(*coords)  # * unpacks coordinates into x, y\n\n        # Update best solution if current is better\n        if value < best_value:\n            best_value, best_coords = value, coords\n\n    return (*best_coords, best_value)  # * unpacks coordinates into return values\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")", "language": "python", "parent_id": "6bd1e317-55db-4318-b635-9375e92fc9bf", "generation": 2, "timestamp": 1755441724.385515, "iteration_found": 18, "metrics": {"runs_successfully": 1.0, "value_score": 0.9310482427654523, "distance_score": 0.8056549808525024, "overall_score": 0.9753807953557034, "standard_deviation_score": 0.8452892425611624, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.8769039767785167, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.9622321231269151, "distance_score": 0.8408513209581386, "overall_score": 0.982319529430134, "standard_deviation_score": 0.9025922086045044, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.9115976471506697, "success_rate": 1.0}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert coder helping to improve programs through evolution.", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 1.0000\n- value_score: 0.9622\n- distance_score: 0.8409\n- overall_score: 0.9823\n- standard_deviation_score: 0.9026\n- speed_score: 1.0000\n- reliability_score: 1.0000\n- combined_score: 0.9116\n- success_rate: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, value_score: 0.9622, distance_score: 0.8409, overall_score: 0.9823, standard_deviation_score: 0.9026, speed_score: 1.0000, reliability_score: 1.0000, combined_score: 0.9116, success_rate: 1.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9555)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random 2D point using vectorized operation\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Generate new candidate solution as a 2D point\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        # Update best solution if current is better\n        if value < best_value:\n            best_value, best_x, best_y = value, x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9622), Performs well on distance_score (0.8409), Performs well on overall_score (0.9823), Performs well on standard_deviation_score (0.9026), Performs well on speed_score (1.0000), Performs well on reliability_score (1.0000), Performs well on combined_score (0.9116), Performs well on success_rate (1.0000)\n\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random 2D point using vectorized operation\n    best_x, best_y = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        # Generate new candidate solution as a 2D point\n        x, y = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(x, y)\n\n        # Update best solution if current is better\n        if value < best_value:\n            best_value, best_x, best_y = value, x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with random coordinates and evaluate\n    best_coords = np.random.uniform(bounds[0], bounds[1], size=2)\n    best_value = evaluate_function(*best_coords)  # * unpacks coordinates into x, y\n\n    for _ in range(iterations):\n        # Generate new candidate solution and evaluate\n        coords = np.random.uniform(bounds[0], bounds[1], size=2)\n        value = evaluate_function(*coords)  # * unpacks coordinates into x, y\n\n        # Update best solution if current is better\n        if value < best_value:\n            best_value, best_coords = value, coords\n\n    return (*best_coords, best_value)  # * unpacks coordinates into return values\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\nThe key improvements made to simplify the code while maintaining identical functionality:\n\n1. Combined `best_x` and `best_y` into a single `best_coords` array, reducing the number of variables to track\n2. Used tuple unpacking (`*`) to simplify passing coordinates to `evaluate_function`\n3. Simplified the return statement by unpacking the coordinates array\n4. Maintained the same algorithm logic and performance characteristics\n5. Added clarifying comments for the unpacking operations\n\nThese changes improve readability by reducing code clutter while maintaining the same inputs, outputs, and performance metrics as the original implementation. The random search algorithm itself remains unchanged in its behavior."]}}}